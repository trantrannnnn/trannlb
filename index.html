<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trợ lý Chatbot RAG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- PDF.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <!-- Mammoth.js for DOCX -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script>
        // Thiết lập worker cho PDF.js để xử lý tệp trong nền
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
    </script>
    <style>
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
        }
        /* Custom scrollbar for webkit browsers */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        .chat-bubble-user {
            background-color: #1e40af; /* Deep Blue */
            color: white;
        }
        .chat-bubble-bot {
            background-color: #e2e8f0; /* Light Gray */
            color: #1e293b;
        }
        .drop-zone-active {
            border-color: #2563eb;
            background-color: #eff6ff;
        }
    </style>
</head>
<body class="bg-slate-100 flex h-screen antialiased text-slate-800">

    <div class="flex flex-col md:flex-row w-full h-full max-w-7xl mx-auto bg-white shadow-2xl rounded-xl overflow-hidden">
        
        <!-- Sidebar for File Uploads -->
        <aside class="w-full md:w-1/3 lg:w-1/4 p-6 bg-slate-50 border-r border-slate-200 flex flex-col">
            <div class="flex items-center gap-3 mb-6">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-600"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><line x1="10" y1="9" x2="8" y2="9"></line></svg>
                <h1 class="text-xl font-bold text-slate-700">Tài liệu của bạn</h1>
            </div>

            <!-- Drop Zone -->
            <div id="drop-zone" class="flex-grow flex flex-col items-center justify-center border-2 border-dashed border-slate-300 rounded-lg p-4 text-center cursor-pointer transition-colors duration-300 hover:bg-slate-100 hover:border-blue-400">
                <input type="file" id="file-input" multiple class="hidden" accept=".pdf,.txt,image/*,.docx">
                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="text-slate-400 mb-2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                <p class="text-slate-500">Kéo & thả tệp vào đây</p>
                <p class="text-sm text-slate-400">hoặc</p>
                <button id="browse-btn" class="mt-2 px-4 py-2 bg-blue-600 text-white rounded-lg shadow-sm hover:bg-blue-700 transition-colors">
                    Chọn tệp
                </button>
                 <p class="text-xs text-slate-400 mt-2">Hỗ trợ Word, PDF, ảnh, và tệp .txt</p>
            </div>

            <!-- File List -->
            <div class="mt-4">
                <h2 class="text-lg font-semibold text-slate-600 mb-2">Tệp đã tải lên:</h2>
                <div id="file-list" class="space-y-2 max-h-48 overflow-y-auto custom-scrollbar pr-2">
                    <!-- Files will be listed here -->
                </div>
            </div>
            <button id="clear-btn" class="mt-auto w-full px-4 py-2 bg-red-500 text-white rounded-lg shadow-sm hover:bg-red-600 transition-colors disabled:bg-red-300 disabled:cursor-not-allowed">
                Xóa tất cả
            </button>
        </aside>

        <!-- Chat Interface -->
        <main class="flex-1 flex flex-col h-full">
            <header class="p-4 border-b border-slate-200 flex justify-between items-center bg-white">
                <h2 class="text-xl font-bold text-slate-800">Trợ lý Chatbot</h2>
                <div id="status-indicator" class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-green-500 rounded-full animate-pulse"></div>
                    <span class="text-sm text-slate-500">Online</span>
                </div>
            </header>

            <!-- Messages -->
            <div id="chat-window" class="flex-1 p-6 overflow-y-auto custom-scrollbar">
                <div class="space-y-6">
                    <!-- Bot Welcome Message -->
                    <div class="flex items-start gap-3">
                        <div class="w-10 h-10 rounded-full bg-blue-600 flex items-center justify-center text-white font-bold text-lg flex-shrink-0">AI</div>
                        <div class="chat-bubble-bot p-4 rounded-lg max-w-lg shadow-sm">
                            <p>Xin chào! Tôi là trợ lý AI của bạn. Hãy tải lên một vài tài liệu (Word, PDF, ảnh hoặc file .txt) để bắt đầu. Sau đó, bạn có thể hỏi tôi bất cứ điều gì về nội dung trong đó.</p>
                        </div>
                    </div>
                    <!-- More messages will be appended here -->
                </div>
            </div>

            <!-- Message Input -->
            <footer class="p-4 bg-white border-t border-slate-200">
                <div class="flex items-center bg-slate-100 rounded-lg p-2">
                    <input type="text" id="user-input" placeholder="Nhập câu hỏi của bạn ở đây..." class="flex-1 bg-transparent border-none focus:ring-0 outline-none px-2 text-slate-700" disabled>
                    <button id="send-btn" class="p-2 rounded-full bg-blue-600 text-white hover:bg-blue-700 disabled:bg-blue-300 disabled:cursor-not-allowed transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                    </button>
                </div>
            </footer>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            const browseBtn = document.getElementById('browse-btn');
            const fileList = document.getElementById('file-list');
            const clearBtn = document.getElementById('clear-btn');
            const chatWindow = document.getElementById('chat-window');
            const userInput = document.getElementById('user-input');
            const sendBtn = document.getElementById('send-btn');

            let documentContext = {
                images: [], // Stores { name, content (base64) }
                textChunks: [] // Stores { source, content }
            };

            // --- File Handling & Chunking ---

            const handleFiles = (files) => {
                if (!files || files.length === 0) return;
                
                Array.from(files).forEach(file => {
                    const fileType = file.type;
                    const fileName = file.name;
                    const reader = new FileReader();

                    if (fileType.startsWith('image/')) {
                        reader.readAsDataURL(file);
                        reader.onload = () => {
                            addFileToList(fileName, 'image', reader.result);
                        };
                    } else if (fileType === 'text/plain') {
                        reader.readAsText(file);
                        reader.onload = () => {
                            addFileToList(fileName, 'text', reader.result);
                        };
                    } else if (fileType === 'application/pdf') {
                        extractTextFromPdf(file);
                    } else if (fileName.endsWith('.docx') || fileType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
                        extractTextFromDocx(file);
                    } else {
                        alert(`Tệp '${fileName}' không được hỗ trợ. Vui lòng chỉ tải lên Word, PDF, ảnh hoặc tệp .txt.`);
                    }
                });
            };
            
            const chunkText = (text, sourceName) => {
                // Chia văn bản thành các đoạn dựa trên dòng trống (đoạn văn)
                const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim().length > 10);
                paragraphs.forEach(p => {
                    documentContext.textChunks.push({ source: sourceName, content: p.trim() });
                });
            };

            const extractTextFromPdf = (file) => {
                addBotMessage(`Đang xử lý tệp PDF: ${file.name}...`, true);
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const pdfData = new Uint8Array(event.target.result);
                    try {
                        const loadingTask = pdfjsLib.getDocument({ data: pdfData });
                        const pdf = await loadingTask.promise;
                        let fullText = '';
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            fullText += textContent.items.map(item => item.str).join(' ') + '\n';
                        }
                        removeLoader();
                        addFileToList(file.name, 'text', fullText.trim());
                    } catch (error) {
                        console.error('Lỗi khi xử lý tệp PDF:', error);
                        alert(`Không thể đọc nội dung từ tệp PDF '${file.name}'.`);
                        removeLoader();
                    }
                };
                reader.readAsArrayBuffer(file);
            };

            const extractTextFromDocx = (file) => {
                addBotMessage(`Đang xử lý tệp Word: ${file.name}...`, true);
                const reader = new FileReader();
                reader.onload = (event) => {
                    mammoth.extractRawText({ arrayBuffer: event.target.result })
                        .then(result => {
                            removeLoader();
                            addFileToList(file.name, 'text', result.value.trim());
                        })
                        .catch(error => {
                            console.error('Lỗi khi xử lý tệp DOCX:', error);
                            alert(`Không thể đọc nội dung từ tệp Word '${file.name}'.`);
                            removeLoader();
                        });
                };
                reader.readAsArrayBuffer(file);
            };

            const addFileToList = (name, type, content) => {
                // Ngăn chặn thêm tệp trùng lặp
                if (type === 'image' && documentContext.images.some(doc => doc.name === name)) return;
                if (type === 'text' && documentContext.textChunks.some(chunk => chunk.source === name)) return;

                if (type === 'image') {
                    documentContext.images.push({ name, content });
                } else if (type === 'text') {
                    chunkText(content, name);
                }

                const fileElement = document.createElement('div');
                fileElement.className = 'flex items-center justify-between bg-white p-2 rounded-md shadow-sm';
                fileElement.innerHTML = `
                    <div class="flex items-center gap-2 overflow-hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-slate-500 flex-shrink-0"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline></svg>
                        <span class="text-sm text-slate-600 truncate">${name}</span>
                    </div>
                `;
                fileList.appendChild(fileElement);
                updateUIState();
            };

            const updateUIState = () => {
                const hasFiles = documentContext.images.length > 0 || documentContext.textChunks.length > 0;
                userInput.disabled = !hasFiles;
                sendBtn.disabled = !hasFiles;
                clearBtn.disabled = !hasFiles;

                if (hasFiles) {
                    userInput.placeholder = "Hỏi bất cứ điều gì về tài liệu của bạn...";
                } else {
                    userInput.placeholder = "Vui lòng tải lên tài liệu để bắt đầu";
                }
            };
            
            const clearAllFiles = () => {
                documentContext = { images: [], textChunks: [] };
                fileList.innerHTML = '';
                addBotMessage("Tất cả tài liệu đã được xóa. Vui lòng tải lên tệp mới để tiếp tục.");
                updateUIState();
            };

            // Event Listeners for file upload
            browseBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
            
            dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('drop-zone-active'); });
            dropZone.addEventListener('dragleave', () => { dropZone.classList.remove('drop-zone-active'); });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drop-zone-active');
                handleFiles(e.dataTransfer.files);
            });
            
            clearBtn.addEventListener('click', clearAllFiles);


            // --- Smart Search & Chat Logic ---

            const findRelevantChunks = (query) => {
                const queryWords = new Set(query.toLowerCase().split(/\s+/).filter(w => w.length > 2));
                if (queryWords.size === 0) {
                    return documentContext.textChunks.slice(0, 5);
                }

                const scoredChunks = documentContext.textChunks.map(chunk => {
                    let score = 0;
                    const chunkWords = new Set(chunk.content.toLowerCase().split(/\s+/));
                    for (const word of queryWords) {
                        if (chunkWords.has(word)) {
                            score++;
                        }
                    }
                    return { ...chunk, score };
                });

                scoredChunks.sort((a, b) => b.score - a.score);
                
                const topChunks = scoredChunks.filter(c => c.score > 0).slice(0, 7);

                if (topChunks.length === 0) {
                    return documentContext.textChunks.slice(0, 5);
                }
                
                return topChunks;
            };

            const addUserMessage = (message) => {
                const messageElement = document.createElement('div');
                messageElement.className = 'flex items-start gap-3 justify-end';
                messageElement.innerHTML = `
                    <div class="chat-bubble-user p-4 rounded-lg max-w-lg shadow-sm">
                        <p>${message}</p>
                    </div>
                    <div class="w-10 h-10 rounded-full bg-slate-600 flex items-center justify-center text-white font-bold text-lg flex-shrink-0">BẠN</div>
                `;
                chatWindow.querySelector('.space-y-6').appendChild(messageElement);
                chatWindow.scrollTop = chatWindow.scrollHeight;
            };

            const removeLoader = () => {
                const existingLoader = document.getElementById('loading-bubble');
                if (existingLoader) existingLoader.remove();
            };

            const addBotMessage = (message, isLoading = false) => {
                removeLoader(); 

                const messageElement = document.createElement('div');
                messageElement.className = 'flex items-start gap-3';
                
                let contentHTML;
                if (isLoading) {
                    messageElement.id = 'loading-bubble';
                    contentHTML = `
                        <div class="flex items-center gap-2">
                           <p class="text-slate-500">${message}</p>
                            <div class="w-2 h-2 bg-slate-500 rounded-full animate-bounce" style="animation-delay: -0.3s;"></div>
                            <div class="w-2 h-2 bg-slate-500 rounded-full animate-bounce" style="animation-delay: -0.15s;"></div>
                            <div class="w-2 h-2 bg-slate-500 rounded-full animate-bounce"></div>
                        </div>
                    `;
                } else {
                     const sanitizedMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                     contentHTML = `<p>${sanitizedMessage}</p>`;
                }

                messageElement.innerHTML = `
                    <div class="w-10 h-10 rounded-full bg-blue-600 flex items-center justify-center text-white font-bold text-lg flex-shrink-0">AI</div>
                    <div class="chat-bubble-bot p-4 rounded-lg max-w-lg shadow-sm">
                        ${contentHTML}
                    </div>
                `;
                chatWindow.querySelector('.space-y-6').appendChild(messageElement);
                chatWindow.scrollTop = chatWindow.scrollHeight;
                return messageElement;
            };

            const handleSendMessage = async () => {
                const userQuery = userInput.value.trim();
                if (!userQuery || (documentContext.images.length === 0 && documentContext.textChunks.length === 0)) return;

                addUserMessage(userQuery);
                userInput.value = '';
                userInput.disabled = true;
                sendBtn.disabled = true;

                addBotMessage('Đang tìm kiếm và suy nghĩ...', true); 

                try {
                    const response = await callGeminiAPI(userQuery);
                    addBotMessage(response);
                } catch (error) {
                    console.error("Lỗi trong lúc gửi tin nhắn:", error);
                    addBotMessage(`Rất tiếc, đã có lỗi xảy ra: ${error.message}`);
                } finally {
                    userInput.disabled = false;
                    sendBtn.disabled = false;
                    userInput.focus();
                }
            };

            sendBtn.addEventListener('click', handleSendMessage);
            userInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleSendMessage(); });

            // --- Gemini API Call (RAG Simulation) ---
            async function callGeminiAPI(userQuery) {
                const apiKey = ""; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${AIzaSyCFGXy1CsBJiBvG9GfvW0lvTz75raq6TlM}`;

                const relevantChunks = findRelevantChunks(userQuery);
                let textContext = relevantChunks
                    .map(chunk => `Trích đoạn từ '${chunk.source}':\n${chunk.content}`)
                    .join('\n\n---\n\n');

                if (textContext.trim() === '' && documentContext.textChunks.length > 0) {
                    textContext = "Không có trích đoạn văn bản nào được tìm thấy là có liên quan đến câu hỏi.";
                } else if (textContext.trim() === '' && documentContext.textChunks.length === 0) {
                    textContext = "Không có nội dung văn bản nào được cung cấp.";
                }

                const imageParts = documentContext.images
                    .map(doc => ({
                        inlineData: {
                            mimeType: doc.content.startsWith('data:image/png') ? 'image/png' : 'image/jpeg',
                            data: doc.content.split(',')[1] 
                        }
                    }));
                
                const systemInstruction = `Bạn là một trợ lý AI, chỉ được phép trả lời dựa trên các trích đoạn thông tin và hình ảnh được cung cấp. Tuyệt đối không được sử dụng kiến thức bên ngoài. Nếu câu trả lời không có trong thông tin được cung cấp, hãy trả lời một cách lịch sự rằng: "Tôi không tìm thấy thông tin về điều này trong các tài liệu bạn đã cung cấp."`;

                const prompt = `Dựa vào các trích đoạn có liên quan nhất sau đây:\n\n${textContext}\n\nHãy phân tích các hình ảnh được cung cấp (nếu có) và trả lời câu hỏi của người dùng: "${userQuery}"`;
                
                const payload = {
                    contents: [{
                        role: "user",
                        parts: [
                            { text: prompt },
                            ...imageParts
                        ]
                    }],
                    systemInstruction: {
                        role: "system",
                        parts: [{ text: systemInstruction }]
                    },
                    generationConfig: {
                        temperature: 0.2,
                        topP: 0.9,
                    }
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorBody;
                    try {
                        errorBody = await response.json();
                        console.error("Phản hồi lỗi từ API:", errorBody);
                    } catch (e) {
                        errorBody = { error: { message: await response.text() || "Không thể đọc phản hồi lỗi." } };
                        console.error("Phản hồi lỗi không phải JSON từ API:", errorBody.error.message);
                    }
                    const errorMessage = errorBody?.error?.message || `Yêu cầu API thất bại với mã trạng thái ${response.status}`;
                    throw new Error(errorMessage);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    console.warn("Cấu trúc phản hồi không mong muốn:", result);
                    if (result.promptFeedback && result.promptFeedback.blockReason) {
                         return `Yêu cầu của bạn đã bị chặn vì lý do: ${result.promptFeedback.blockReason}. Vui lòng thử lại với một câu hỏi khác.`;
                    }
                    return "Tôi không thể tạo ra câu trả lời vào lúc này. Vui lòng thử lại.";
                }
            }
            
            updateUIState();
        });
    </script>
</body>
</html>
